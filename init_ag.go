// Code generated by https://github.com/expgo/ag DO NOT EDIT.
// Plugins:
//   - github.com/expgo/enum

package fins

import (
	"errors"
	"fmt"
	"strings"
)

const (
	// AreaCIO is an Area of type CIO.
	AreaCIO Area = "CIO"
	// AreaWR is an Area of type WR.
	AreaWR Area = "WR"
	// AreaHR is an Area of type HR.
	AreaHR Area = "HR"
	// AreaAR is an Area of type AR.
	AreaAR Area = "AR"
	// AreaTIM is an Area of type TIM.
	AreaTIM Area = "TIM"
	// AreaCNT is an Area of type CNT.
	AreaCNT Area = "CNT"
	// AreaDM is an Area of type DM.
	AreaDM Area = "DM"
	// AreaIR is an Area of type IR.
	AreaIR Area = "IR"
	// AreaDR is an Area of type DR.
	AreaDR Area = "DR"
)

const (
	// CommandMemoryRead is a Command of type MemoryRead.
	CommandMemoryRead Command = iota
	// CommandMemoryWrite is a Command of type MemoryWrite.
	CommandMemoryWrite
	// CommandMemoryFill is a Command of type MemoryFill.
	CommandMemoryFill
	// CommandMultipleMemoryRead is a Command of type MultipleMemoryRead.
	CommandMultipleMemoryRead
	// CommandMemoryTransfer is a Command of type MemoryTransfer.
	CommandMemoryTransfer
)

const (
	// DataTypeBit is a DataType of type Bit.
	DataTypeBit DataType = "Bit"
	// DataTypeBitFs is a DataType of type BitFs.
	DataTypeBitFs DataType = "BitFs"
	// DataTypeWord is a DataType of type Word.
	DataTypeWord DataType = "Word"
	// DataTypeWordFs is a DataType of type WordFs.
	DataTypeWordFs DataType = "WordFs"
	// DataTypeCF is a DataType of type CF.
	DataTypeCF DataType = "CF"
	// DataTypeCFFs is a DataType of type CFFs.
	DataTypeCFFs DataType = "CFFs"
	// DataTypePV is a DataType of type PV.
	DataTypePV DataType = "PV"
)

const (
	// MemoryAreaCIOBit is a MemoryArea of type CIOBit.
	MemoryAreaCIOBit MemoryArea = "CIOBit" // CIO Area Bit
	// MemoryAreaWRBit is a MemoryArea of type WRBit.
	MemoryAreaWRBit MemoryArea = "WRBit" // Work Area Bit
	// MemoryAreaHRBit is a MemoryArea of type HRBit.
	MemoryAreaHRBit MemoryArea = "HRBit" // Holding Bit Area Bit
	// MemoryAreaARBit is a MemoryArea of type ARBit.
	MemoryAreaARBit MemoryArea = "ARBit" // Auxiliary Bit Area Bit
	// MemoryAreaCIOBitFs is a MemoryArea of type CIOBitFs.
	MemoryAreaCIOBitFs MemoryArea = "CIOBitFs" // CIO Area Bit with forced status
	// MemoryAreaWRBitFs is a MemoryArea of type WRBitFs.
	MemoryAreaWRBitFs MemoryArea = "WRBitFs" // Work Area Bit with forced status
	// MemoryAreaHRBitFs is a MemoryArea of type HRBitFs.
	MemoryAreaHRBitFs MemoryArea = "HRBitFs" // Holding Bit Area Bit with forced status
	// MemoryAreaCIOWord is a MemoryArea of type CIOWord.
	MemoryAreaCIOWord MemoryArea = "CIOWord" // CIO Area Word
	// MemoryAreaWRWord is a MemoryArea of type WRWord.
	MemoryAreaWRWord MemoryArea = "WRWord" // Work Area Word
	// MemoryAreaHRWord is a MemoryArea of type HRWord.
	MemoryAreaHRWord MemoryArea = "HRWord" // Holding Bit Area Word
	// MemoryAreaARWord is a MemoryArea of type ARWord.
	MemoryAreaARWord MemoryArea = "ARWord" // Auxiliary Bit Area Word
	// MemoryAreaCIOWordFs is a MemoryArea of type CIOWordFs.
	MemoryAreaCIOWordFs MemoryArea = "CIOWordFs" // CIO Area Word with forced status
	// MemoryAreaWRWordFs is a MemoryArea of type WRWordFs.
	MemoryAreaWRWordFs MemoryArea = "WRWordFs" // Work Area Word with forced status
	// MemoryAreaHRWordFs is a MemoryArea of type HRWordFs.
	MemoryAreaHRWordFs MemoryArea = "HRWordFs" // Holding Bit Area Word with forced status
	// MemoryAreaTIMCF is a MemoryArea of type TIMCF.
	MemoryAreaTIMCF MemoryArea = "TIMCF" // Timer Area
	// MemoryAreaCNTCF is a MemoryArea of type CNTCF.
	MemoryAreaCNTCF MemoryArea = "CNTCF" // Counter Area
	// MemoryAreaTIMCFFs is a MemoryArea of type TIMCFFs.
	MemoryAreaTIMCFFs MemoryArea = "TIMCFFs" // Timer Area with forced status
	// MemoryAreaCNTCFFs is a MemoryArea of type CNTCFFs.
	MemoryAreaCNTCFFs MemoryArea = "CNTCFFs" // Counter Area with forced status
	// MemoryAreaTIMPV is a MemoryArea of type TIMPV.
	MemoryAreaTIMPV MemoryArea = "TIMPV" // Timer Area
	// MemoryAreaCNTPV is a MemoryArea of type CNTPV.
	MemoryAreaCNTPV MemoryArea = "CNTPV" // Counter Area
	// MemoryAreaDMBit is a MemoryArea of type DMBit.
	MemoryAreaDMBit MemoryArea = "DMBit" // DM Area
	// MemoryAreaDMWord is a MemoryArea of type DMWord.
	MemoryAreaDMWord MemoryArea = "DMWord" // DM Area
	// MemoryAreaIRPV is a MemoryArea of type IRPV.
	MemoryAreaIRPV MemoryArea = "IRPV" // Index Register
	// MemoryAreaDRPV is a MemoryArea of type DRPV.
	MemoryAreaDRPV MemoryArea = "DRPV" // Data Register
)

const (
	// PlcTypeNew is a PlcType of type New.
	PlcTypeNew PlcType = iota
	// PlcTypeOld is a PlcType of type Old.
	PlcTypeOld
)

var ErrInvalidArea = errors.New("not a valid Area")

var _AreaNameMap = map[string]Area{
	"CIO": AreaCIO,
	"cio": AreaCIO,
	"WR":  AreaWR,
	"wr":  AreaWR,
	"HR":  AreaHR,
	"hr":  AreaHR,
	"AR":  AreaAR,
	"ar":  AreaAR,
	"TIM": AreaTIM,
	"tim": AreaTIM,
	"CNT": AreaCNT,
	"cnt": AreaCNT,
	"DM":  AreaDM,
	"dm":  AreaDM,
	"IR":  AreaIR,
	"ir":  AreaIR,
	"DR":  AreaDR,
	"dr":  AreaDR,
}

// Name is the attribute of Area.
func (x Area) Name() string {
	if v, ok := _AreaNameMap[string(x)]; ok {
		return string(v)
	}
	return fmt.Sprintf("Area(%s).Name", string(x))
}

// Val is the attribute of Area.
func (x Area) Val() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x Area) IsValid() bool {
	_, ok := _AreaNameMap[string(x)]
	return ok
}

// String implements the Stringer interface.
func (x Area) String() string {
	return x.Name()
}

// ParseArea converts a string to an Area.
func ParseArea(value string) (Area, error) {
	if x, ok := _AreaNameMap[value]; ok {
		return x, nil
	}
	if x, ok := _AreaNameMap[strings.ToLower(value)]; ok {
		return x, nil
	}
	return "", fmt.Errorf("%s is %w", value, ErrInvalidArea)
}

var ErrInvalidCommand = errors.New("not a valid Command")

var _CommandName = "MemoryReadMemoryWriteMemoryFillMultipleMemoryReadMemoryTransfer"

var _CommandMapName = map[Command]string{
	CommandMemoryRead:         _CommandName[0:10],
	CommandMemoryWrite:        _CommandName[10:21],
	CommandMemoryFill:         _CommandName[21:31],
	CommandMultipleMemoryRead: _CommandName[31:49],
	CommandMemoryTransfer:     _CommandName[49:63],
}

// Name is the attribute of Command.
func (x Command) Name() string {
	if v, ok := _CommandMapName[x]; ok {
		return v
	}
	return fmt.Sprintf("Command(%d).Name", x)
}

var _CommandMapMr = map[Command]uint8{
	CommandMemoryRead:         1,
	CommandMemoryWrite:        1,
	CommandMemoryFill:         1,
	CommandMultipleMemoryRead: 1,
	CommandMemoryTransfer:     1,
}

// Mr is the attribute of Command.
func (x Command) Mr() uint8 {
	if v, ok := _CommandMapMr[x]; ok {
		return v
	}
	return 0
}

var _CommandMapSr = map[Command]uint8{
	CommandMemoryRead:         1,
	CommandMemoryWrite:        2,
	CommandMemoryFill:         3,
	CommandMultipleMemoryRead: 4,
	CommandMemoryTransfer:     5,
}

// Sr is the attribute of Command.
func (x Command) Sr() uint8 {
	if v, ok := _CommandMapSr[x]; ok {
		return v
	}
	return 0
}

// Val is the attribute of Command.
func (x Command) Val() int {
	return int(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x Command) IsValid() bool {
	_, ok := _CommandMapName[x]
	return ok
}

// String implements the Stringer interface.
func (x Command) String() string {
	return x.Name()
}

var _CommandNameMap = map[string]Command{
	_CommandName[0:10]:  CommandMemoryRead,
	_CommandName[10:21]: CommandMemoryWrite,
	_CommandName[21:31]: CommandMemoryFill,
	_CommandName[31:49]: CommandMultipleMemoryRead,
	_CommandName[49:63]: CommandMemoryTransfer,
}

// ParseCommand converts a string to a Command.
func ParseCommand(value string) (Command, error) {
	if x, ok := _CommandNameMap[value]; ok {
		return x, nil
	}
	return Command(0), fmt.Errorf("%s is %w", value, ErrInvalidCommand)
}

var ErrInvalidDataType = errors.New("not a valid DataType")

var _DataTypeNameMap = map[string]DataType{
	"Bit":    DataTypeBit,
	"BitFs":  DataTypeBitFs,
	"Word":   DataTypeWord,
	"WordFs": DataTypeWordFs,
	"CF":     DataTypeCF,
	"CFFs":   DataTypeCFFs,
	"PV":     DataTypePV,
}

// Name is the attribute of DataType.
func (x DataType) Name() string {
	if v, ok := _DataTypeNameMap[string(x)]; ok {
		return string(v)
	}
	return fmt.Sprintf("DataType(%s).Name", string(x))
}

// Val is the attribute of DataType.
func (x DataType) Val() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x DataType) IsValid() bool {
	_, ok := _DataTypeNameMap[string(x)]
	return ok
}

// String implements the Stringer interface.
func (x DataType) String() string {
	return x.Name()
}

// ParseDataType converts a string to a DataType.
func ParseDataType(value string) (DataType, error) {
	if x, ok := _DataTypeNameMap[value]; ok {
		return x, nil
	}
	return "", fmt.Errorf("%s is %w", value, ErrInvalidDataType)
}

var ErrInvalidMemoryArea = errors.New("not a valid MemoryArea")

var _MemoryAreaNameMap = map[string]MemoryArea{
	"CIOBit":    MemoryAreaCIOBit,
	"ciobit":    MemoryAreaCIOBit,
	"WRBit":     MemoryAreaWRBit,
	"wrbit":     MemoryAreaWRBit,
	"HRBit":     MemoryAreaHRBit,
	"hrbit":     MemoryAreaHRBit,
	"ARBit":     MemoryAreaARBit,
	"arbit":     MemoryAreaARBit,
	"CIOBitFs":  MemoryAreaCIOBitFs,
	"ciobitfs":  MemoryAreaCIOBitFs,
	"WRBitFs":   MemoryAreaWRBitFs,
	"wrbitfs":   MemoryAreaWRBitFs,
	"HRBitFs":   MemoryAreaHRBitFs,
	"hrbitfs":   MemoryAreaHRBitFs,
	"CIOWord":   MemoryAreaCIOWord,
	"cioword":   MemoryAreaCIOWord,
	"WRWord":    MemoryAreaWRWord,
	"wrword":    MemoryAreaWRWord,
	"HRWord":    MemoryAreaHRWord,
	"hrword":    MemoryAreaHRWord,
	"ARWord":    MemoryAreaARWord,
	"arword":    MemoryAreaARWord,
	"CIOWordFs": MemoryAreaCIOWordFs,
	"ciowordfs": MemoryAreaCIOWordFs,
	"WRWordFs":  MemoryAreaWRWordFs,
	"wrwordfs":  MemoryAreaWRWordFs,
	"HRWordFs":  MemoryAreaHRWordFs,
	"hrwordfs":  MemoryAreaHRWordFs,
	"TIMCF":     MemoryAreaTIMCF,
	"timcf":     MemoryAreaTIMCF,
	"CNTCF":     MemoryAreaCNTCF,
	"cntcf":     MemoryAreaCNTCF,
	"TIMCFFs":   MemoryAreaTIMCFFs,
	"timcffs":   MemoryAreaTIMCFFs,
	"CNTCFFs":   MemoryAreaCNTCFFs,
	"cntcffs":   MemoryAreaCNTCFFs,
	"TIMPV":     MemoryAreaTIMPV,
	"timpv":     MemoryAreaTIMPV,
	"CNTPV":     MemoryAreaCNTPV,
	"cntpv":     MemoryAreaCNTPV,
	"DMBit":     MemoryAreaDMBit,
	"dmbit":     MemoryAreaDMBit,
	"DMWord":    MemoryAreaDMWord,
	"dmword":    MemoryAreaDMWord,
	"IRPV":      MemoryAreaIRPV,
	"irpv":      MemoryAreaIRPV,
	"DRPV":      MemoryAreaDRPV,
	"drpv":      MemoryAreaDRPV,
}

// Name is the attribute of MemoryArea.
func (x MemoryArea) Name() string {
	if v, ok := _MemoryAreaNameMap[string(x)]; ok {
		return string(v)
	}
	return fmt.Sprintf("MemoryArea(%s).Name", string(x))
}

var _MemoryAreaMapAreaName = map[MemoryArea]string{
	MemoryAreaCIOBit:    "CIO",
	MemoryAreaWRBit:     "WR",
	MemoryAreaHRBit:     "HR",
	MemoryAreaARBit:     "AR",
	MemoryAreaCIOBitFs:  "CIO",
	MemoryAreaWRBitFs:   "WR",
	MemoryAreaHRBitFs:   "HR",
	MemoryAreaCIOWord:   "CIO",
	MemoryAreaWRWord:    "WR",
	MemoryAreaHRWord:    "HR",
	MemoryAreaARWord:    "AR",
	MemoryAreaCIOWordFs: "CIO",
	MemoryAreaWRWordFs:  "WR",
	MemoryAreaHRWordFs:  "HR",
	MemoryAreaTIMCF:     "TIM",
	MemoryAreaCNTCF:     "CNT",
	MemoryAreaTIMCFFs:   "TIM",
	MemoryAreaCNTCFFs:   "CNT",
	MemoryAreaTIMPV:     "TIM",
	MemoryAreaCNTPV:     "CNT",
	MemoryAreaDMBit:     "DM",
	MemoryAreaDMWord:    "DM",
	MemoryAreaIRPV:      "IR",
	MemoryAreaDRPV:      "DR",
}

// AreaName is the attribute of MemoryArea.
func (x MemoryArea) AreaName() string {
	if v, ok := _MemoryAreaMapAreaName[x]; ok {
		return v
	}
	return fmt.Sprintf("MemoryArea(%s).AreaName", string(x))
}

var _MemoryAreaMapDataType = map[MemoryArea]string{
	MemoryAreaCIOBit:    "Bit",
	MemoryAreaWRBit:     "Bit",
	MemoryAreaHRBit:     "Bit",
	MemoryAreaARBit:     "Bit",
	MemoryAreaCIOBitFs:  "BitFs",
	MemoryAreaWRBitFs:   "BitFs",
	MemoryAreaHRBitFs:   "BitFs",
	MemoryAreaCIOWord:   "Word",
	MemoryAreaWRWord:    "Word",
	MemoryAreaHRWord:    "Word",
	MemoryAreaARWord:    "Word",
	MemoryAreaCIOWordFs: "WordFs",
	MemoryAreaWRWordFs:  "WordFs",
	MemoryAreaHRWordFs:  "WordFs",
	MemoryAreaTIMCF:     "CF",
	MemoryAreaCNTCF:     "CF",
	MemoryAreaTIMCFFs:   "CFFs",
	MemoryAreaCNTCFFs:   "CFFs",
	MemoryAreaTIMPV:     "PV",
	MemoryAreaCNTPV:     "PV",
	MemoryAreaDMBit:     "Bit",
	MemoryAreaDMWord:    "Word",
	MemoryAreaIRPV:      "PV",
	MemoryAreaDRPV:      "PV",
}

// DataType is the attribute of MemoryArea.
func (x MemoryArea) DataType() string {
	if v, ok := _MemoryAreaMapDataType[x]; ok {
		return v
	}
	return fmt.Sprintf("MemoryArea(%s).DataType", string(x))
}

var _MemoryAreaMapCode = map[MemoryArea]uint8{
	MemoryAreaCIOBit:    48,
	MemoryAreaWRBit:     49,
	MemoryAreaHRBit:     50,
	MemoryAreaARBit:     51,
	MemoryAreaCIOBitFs:  112,
	MemoryAreaWRBitFs:   113,
	MemoryAreaHRBitFs:   114,
	MemoryAreaCIOWord:   176,
	MemoryAreaWRWord:    177,
	MemoryAreaHRWord:    178,
	MemoryAreaARWord:    179,
	MemoryAreaCIOWordFs: 240,
	MemoryAreaWRWordFs:  241,
	MemoryAreaHRWordFs:  242,
	MemoryAreaTIMCF:     9,
	MemoryAreaCNTCF:     9,
	MemoryAreaTIMCFFs:   73,
	MemoryAreaCNTCFFs:   73,
	MemoryAreaTIMPV:     137,
	MemoryAreaCNTPV:     137,
	MemoryAreaDMBit:     2,
	MemoryAreaDMWord:    130,
	MemoryAreaIRPV:      220,
	MemoryAreaDRPV:      188,
}

// Code is the attribute of MemoryArea.
func (x MemoryArea) Code() uint8 {
	if v, ok := _MemoryAreaMapCode[x]; ok {
		return v
	}
	return 0
}

var _MemoryAreaMapMax = map[MemoryArea]uint16{
	MemoryAreaCIOBit:    6143,
	MemoryAreaWRBit:     511,
	MemoryAreaHRBit:     511,
	MemoryAreaARBit:     959,
	MemoryAreaCIOBitFs:  6143,
	MemoryAreaWRBitFs:   511,
	MemoryAreaHRBitFs:   511,
	MemoryAreaCIOWord:   6143,
	MemoryAreaWRWord:    511,
	MemoryAreaHRWord:    511,
	MemoryAreaARWord:    959,
	MemoryAreaCIOWordFs: 6143,
	MemoryAreaWRWordFs:  511,
	MemoryAreaHRWordFs:  511,
	MemoryAreaTIMCF:     4095,
	MemoryAreaCNTCF:     4095,
	MemoryAreaTIMCFFs:   4095,
	MemoryAreaCNTCFFs:   4095,
	MemoryAreaTIMPV:     4095,
	MemoryAreaCNTPV:     4095,
	MemoryAreaDMBit:     32767,
	MemoryAreaDMWord:    32767,
	MemoryAreaIRPV:      15,
	MemoryAreaDRPV:      15,
}

// Max is the attribute of MemoryArea.
func (x MemoryArea) Max() uint16 {
	if v, ok := _MemoryAreaMapMax[x]; ok {
		return v
	}
	return 0
}

var _MemoryAreaMapOffset = map[MemoryArea]uint16{
	MemoryAreaCIOBit:    0,
	MemoryAreaWRBit:     0,
	MemoryAreaHRBit:     0,
	MemoryAreaARBit:     0,
	MemoryAreaCIOBitFs:  0,
	MemoryAreaWRBitFs:   0,
	MemoryAreaHRBitFs:   0,
	MemoryAreaCIOWord:   0,
	MemoryAreaWRWord:    0,
	MemoryAreaHRWord:    0,
	MemoryAreaARWord:    0,
	MemoryAreaCIOWordFs: 0,
	MemoryAreaWRWordFs:  0,
	MemoryAreaHRWordFs:  0,
	MemoryAreaTIMCF:     0,
	MemoryAreaCNTCF:     32768,
	MemoryAreaTIMCFFs:   0,
	MemoryAreaCNTCFFs:   32768,
	MemoryAreaTIMPV:     0,
	MemoryAreaCNTPV:     32768,
	MemoryAreaDMBit:     0,
	MemoryAreaDMWord:    0,
	MemoryAreaIRPV:      256,
	MemoryAreaDRPV:      512,
}

// Offset is the attribute of MemoryArea.
func (x MemoryArea) Offset() uint16 {
	if v, ok := _MemoryAreaMapOffset[x]; ok {
		return v
	}
	return 0
}

var _MemoryAreaMapOldCode = map[MemoryArea]uint8{
	MemoryAreaCIOBit:    0,
	MemoryAreaWRBit:     0,
	MemoryAreaHRBit:     0,
	MemoryAreaARBit:     0,
	MemoryAreaCIOBitFs:  64,
	MemoryAreaWRBitFs:   0,
	MemoryAreaHRBitFs:   0,
	MemoryAreaCIOWord:   128,
	MemoryAreaWRWord:    0,
	MemoryAreaHRWord:    0,
	MemoryAreaARWord:    128,
	MemoryAreaCIOWordFs: 192,
	MemoryAreaWRWordFs:  0,
	MemoryAreaHRWordFs:  0,
	MemoryAreaTIMCF:     1,
	MemoryAreaCNTCF:     1,
	MemoryAreaTIMCFFs:   65,
	MemoryAreaCNTCFFs:   65,
	MemoryAreaTIMPV:     129,
	MemoryAreaCNTPV:     129,
	MemoryAreaDMBit:     0,
	MemoryAreaDMWord:    130,
	MemoryAreaIRPV:      0,
	MemoryAreaDRPV:      156,
}

// OldCode is the attribute of MemoryArea.
func (x MemoryArea) OldCode() uint8 {
	if v, ok := _MemoryAreaMapOldCode[x]; ok {
		return v
	}
	return 0
}

var _MemoryAreaMapOldMax = map[MemoryArea]uint16{
	MemoryAreaCIOBit:    2555,
	MemoryAreaWRBit:     65535,
	MemoryAreaHRBit:     65535,
	MemoryAreaARBit:     959,
	MemoryAreaCIOBitFs:  2555,
	MemoryAreaWRBitFs:   65535,
	MemoryAreaHRBitFs:   65535,
	MemoryAreaCIOWord:   2555,
	MemoryAreaWRWord:    65535,
	MemoryAreaHRWord:    65535,
	MemoryAreaARWord:    959,
	MemoryAreaCIOWordFs: 2555,
	MemoryAreaWRWordFs:  65535,
	MemoryAreaHRWordFs:  65535,
	MemoryAreaTIMCF:     2047,
	MemoryAreaCNTCF:     2047,
	MemoryAreaTIMCFFs:   2047,
	MemoryAreaCNTCFFs:   2047,
	MemoryAreaTIMPV:     2047,
	MemoryAreaCNTPV:     2047,
	MemoryAreaDMBit:     65535,
	MemoryAreaDMWord:    32767,
	MemoryAreaIRPV:      65535,
	MemoryAreaDRPV:      2,
}

// OldMax is the attribute of MemoryArea.
func (x MemoryArea) OldMax() uint16 {
	if v, ok := _MemoryAreaMapOldMax[x]; ok {
		return v
	}
	return 0
}

var _MemoryAreaMapOldOffset = map[MemoryArea]uint16{
	MemoryAreaCIOBit:    0,
	MemoryAreaWRBit:     65535,
	MemoryAreaHRBit:     65535,
	MemoryAreaARBit:     2816,
	MemoryAreaCIOBitFs:  0,
	MemoryAreaWRBitFs:   65535,
	MemoryAreaHRBitFs:   65535,
	MemoryAreaCIOWord:   0,
	MemoryAreaWRWord:    65535,
	MemoryAreaHRWord:    65535,
	MemoryAreaARWord:    2816,
	MemoryAreaCIOWordFs: 0,
	MemoryAreaWRWordFs:  65535,
	MemoryAreaHRWordFs:  65535,
	MemoryAreaTIMCF:     0,
	MemoryAreaCNTCF:     2048,
	MemoryAreaTIMCFFs:   0,
	MemoryAreaCNTCFFs:   2048,
	MemoryAreaTIMPV:     0,
	MemoryAreaCNTPV:     2048,
	MemoryAreaDMBit:     65535,
	MemoryAreaDMWord:    0,
	MemoryAreaIRPV:      65535,
	MemoryAreaDRPV:      3,
}

// OldOffset is the attribute of MemoryArea.
func (x MemoryArea) OldOffset() uint16 {
	if v, ok := _MemoryAreaMapOldOffset[x]; ok {
		return v
	}
	return 0
}

var _MemoryAreaMapSize = map[MemoryArea]int{
	MemoryAreaCIOBit:    1,
	MemoryAreaWRBit:     1,
	MemoryAreaHRBit:     1,
	MemoryAreaARBit:     1,
	MemoryAreaCIOBitFs:  1,
	MemoryAreaWRBitFs:   1,
	MemoryAreaHRBitFs:   1,
	MemoryAreaCIOWord:   2,
	MemoryAreaWRWord:    2,
	MemoryAreaHRWord:    2,
	MemoryAreaARWord:    2,
	MemoryAreaCIOWordFs: 4,
	MemoryAreaWRWordFs:  4,
	MemoryAreaHRWordFs:  4,
	MemoryAreaTIMCF:     1,
	MemoryAreaCNTCF:     1,
	MemoryAreaTIMCFFs:   1,
	MemoryAreaCNTCFFs:   1,
	MemoryAreaTIMPV:     2,
	MemoryAreaCNTPV:     2,
	MemoryAreaDMBit:     1,
	MemoryAreaDMWord:    2,
	MemoryAreaIRPV:      4,
	MemoryAreaDRPV:      2,
}

// Size is the attribute of MemoryArea.
func (x MemoryArea) Size() int {
	if v, ok := _MemoryAreaMapSize[x]; ok {
		return v
	}
	return 0
}

// Val is the attribute of MemoryArea.
func (x MemoryArea) Val() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x MemoryArea) IsValid() bool {
	_, ok := _MemoryAreaNameMap[string(x)]
	return ok
}

// String implements the Stringer interface.
func (x MemoryArea) String() string {
	return x.Name()
}

// ParseMemoryArea converts a string to a MemoryArea.
func ParseMemoryArea(value string) (MemoryArea, error) {
	if x, ok := _MemoryAreaNameMap[value]; ok {
		return x, nil
	}
	if x, ok := _MemoryAreaNameMap[strings.ToLower(value)]; ok {
		return x, nil
	}
	return "", fmt.Errorf("%s is %w", value, ErrInvalidMemoryArea)
}

// MustParseMemoryArea converts a string to a MemoryArea, and panics if is not valid.
func MustParseMemoryArea(value string) MemoryArea {
	val, err := ParseMemoryArea(value)
	if err != nil {
		panic(err)
	}
	return val
}

var ErrInvalidPlcType = errors.New("not a valid PlcType")

var _PlcTypeName = "NewOld"

var _PlcTypeMapName = map[PlcType]string{
	PlcTypeNew: _PlcTypeName[0:3],
	PlcTypeOld: _PlcTypeName[3:6],
}

// Name is the attribute of PlcType.
func (x PlcType) Name() string {
	if v, ok := _PlcTypeMapName[x]; ok {
		return v
	}
	return fmt.Sprintf("PlcType(%d).Name", x)
}

var _PlcTypeMapDescription = map[PlcType]string{
	PlcTypeNew: "CS/CJ/CP/NSJ-series",
	PlcTypeOld: "CVM1/CV-series",
}

// Description is the attribute of PlcType.
func (x PlcType) Description() string {
	if v, ok := _PlcTypeMapDescription[x]; ok {
		return v
	}
	return fmt.Sprintf("PlcType(%d).Description", x)
}

// Val is the attribute of PlcType.
func (x PlcType) Val() int {
	return int(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x PlcType) IsValid() bool {
	_, ok := _PlcTypeMapName[x]
	return ok
}

// String implements the Stringer interface.
func (x PlcType) String() string {
	return x.Name()
}

var _PlcTypeNameMap = map[string]PlcType{
	_PlcTypeName[0:3]: PlcTypeNew,
	_PlcTypeName[3:6]: PlcTypeOld,
}

// ParsePlcType converts a string to a PlcType.
func ParsePlcType(value string) (PlcType, error) {
	if x, ok := _PlcTypeNameMap[value]; ok {
		return x, nil
	}
	return PlcType(0), fmt.Errorf("%s is %w", value, ErrInvalidPlcType)
}
