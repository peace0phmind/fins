// Code generated by https://github.com/expgo/ag DO NOT EDIT.
// Plugins:
//   - github.com/expgo/enum

package fins

import (
	"errors"
	"fmt"
	"strings"
)

const (
	// AreaCIO is an Area of type CIO.
	AreaCIO Area = "CIO"
	// AreaWR is an Area of type WR.
	AreaWR Area = "WR"
	// AreaHR is an Area of type HR.
	AreaHR Area = "HR"
	// AreaAR is an Area of type AR.
	AreaAR Area = "AR"
	// AreaTIM is an Area of type TIM.
	AreaTIM Area = "TIM"
	// AreaCNT is an Area of type CNT.
	AreaCNT Area = "CNT"
	// AreaDM is an Area of type DM.
	AreaDM Area = "DM"
	// AreaIR is an Area of type IR.
	AreaIR Area = "IR"
	// AreaDR is an Area of type DR.
	AreaDR Area = "DR"
)

const (
	// CommandMemoryRead is a Command of type MemoryRead.
	CommandMemoryRead Command = iota
	// CommandMemoryWrite is a Command of type MemoryWrite.
	CommandMemoryWrite
	// CommandMemoryFill is a Command of type MemoryFill.
	CommandMemoryFill
	// CommandMultipleMemoryRead is a Command of type MultipleMemoryRead.
	CommandMultipleMemoryRead
	// CommandMemoryTransfer is a Command of type MemoryTransfer.
	CommandMemoryTransfer
)

const (
	// DataTypeBit is a DataType of type Bit.
	DataTypeBit DataType = "Bit"
	// DataTypeBitFs is a DataType of type BitFs.
	DataTypeBitFs DataType = "BitFs"
	// DataTypeWord is a DataType of type Word.
	DataTypeWord DataType = "Word"
	// DataTypeWordFs is a DataType of type WordFs.
	DataTypeWordFs DataType = "WordFs"
	// DataTypeCF is a DataType of type CF.
	DataTypeCF DataType = "CF"
	// DataTypeCFFs is a DataType of type CFFs.
	DataTypeCFFs DataType = "CFFs"
	// DataTypePV is a DataType of type PV.
	DataTypePV DataType = "PV"
)

const (
	// MemoryAreaCIOBit is a MemoryArea of type CIOBit.
	MemoryAreaCIOBit MemoryArea = iota // CIO Area Bit
	// MemoryAreaWBit is a MemoryArea of type WBit.
	MemoryAreaWBit // Work Area Bit
	// MemoryAreaHBit is a MemoryArea of type HBit.
	MemoryAreaHBit // Holding Bit Area Bit
	// MemoryAreaABit is a MemoryArea of type ABit.
	MemoryAreaABit // Auxiliary Bit Area Bit
	// MemoryAreaCIOBitFs is a MemoryArea of type CIOBitFs.
	MemoryAreaCIOBitFs // CIO Area Bit with forced status
	// MemoryAreaWBitFs is a MemoryArea of type WBitFs.
	MemoryAreaWBitFs // Work Area Bit with forced status
	// MemoryAreaHBitFs is a MemoryArea of type HBitFs.
	MemoryAreaHBitFs // Holding Bit Area Bit with forced status
	// MemoryAreaCIOWord is a MemoryArea of type CIOWord.
	MemoryAreaCIOWord // CIO Area Word
	// MemoryAreaWWord is a MemoryArea of type WWord.
	MemoryAreaWWord // Work Area Word
	// MemoryAreaHWord is a MemoryArea of type HWord.
	MemoryAreaHWord // Holding Bit Area Word
	// MemoryAreaAWord is a MemoryArea of type AWord.
	MemoryAreaAWord // Auxiliary Bit Area Word
	// MemoryAreaCIOWordFs is a MemoryArea of type CIOWordFs.
	MemoryAreaCIOWordFs // CIO Area Word with forced status
	// MemoryAreaWWordFs is a MemoryArea of type WWordFs.
	MemoryAreaWWordFs // Work Area Word with forced status
	// MemoryAreaHWordFs is a MemoryArea of type HWordFs.
	MemoryAreaHWordFs // Holding Bit Area Word with forced status
	// MemoryAreaTBit is a MemoryArea of type TBit.
	MemoryAreaTBit // Timer Area
	// MemoryAreaCBit is a MemoryArea of type CBit.
	MemoryAreaCBit // Counter Area
	// MemoryAreaTBitFs is a MemoryArea of type TBitFs.
	MemoryAreaTBitFs // Timer Area with forced status
	// MemoryAreaCBitFs is a MemoryArea of type CBitFs.
	MemoryAreaCBitFs // Counter Area with forced status
	// MemoryAreaTWord is a MemoryArea of type TWord.
	MemoryAreaTWord // Timer Area
	// MemoryAreaCWord is a MemoryArea of type CWord.
	MemoryAreaCWord // Counter Area
	// MemoryAreaDBit is a MemoryArea of type DBit.
	MemoryAreaDBit // DM Area
	// MemoryAreaDWord is a MemoryArea of type DWord.
	MemoryAreaDWord // DM Area
	// MemoryAreaIR is a MemoryArea of type IR.
	MemoryAreaIR // Index Register
	// MemoryAreaDR is a MemoryArea of type DR.
	MemoryAreaDR // Data Register
)

const (
	// PlcTypeNew is a PlcType of type New.
	PlcTypeNew PlcType = iota
	// PlcTypeOld is a PlcType of type Old.
	PlcTypeOld
)

var ErrInvalidArea = errors.New("not a valid Area")

var _AreaNameMap = map[string]Area{
	"CIO": AreaCIO,
	"cio": AreaCIO,
	"WR":  AreaWR,
	"wr":  AreaWR,
	"HR":  AreaHR,
	"hr":  AreaHR,
	"AR":  AreaAR,
	"ar":  AreaAR,
	"TIM": AreaTIM,
	"tim": AreaTIM,
	"CNT": AreaCNT,
	"cnt": AreaCNT,
	"DM":  AreaDM,
	"dm":  AreaDM,
	"IR":  AreaIR,
	"ir":  AreaIR,
	"DR":  AreaDR,
	"dr":  AreaDR,
}

// Name is the attribute of Area.
func (x Area) Name() string {
	if v, ok := _AreaNameMap[string(x)]; ok {
		return string(v)
	}
	return fmt.Sprintf("Area(%s).Name", string(x))
}

// Val is the attribute of Area.
func (x Area) Val() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x Area) IsValid() bool {
	_, ok := _AreaNameMap[string(x)]
	return ok
}

// String implements the Stringer interface.
func (x Area) String() string {
	return x.Name()
}

// ParseArea converts a string to an Area.
func ParseArea(value string) (Area, error) {
	if x, ok := _AreaNameMap[value]; ok {
		return x, nil
	}
	if x, ok := _AreaNameMap[strings.ToLower(value)]; ok {
		return x, nil
	}
	return "", fmt.Errorf("%s is %w", value, ErrInvalidArea)
}

var ErrInvalidCommand = errors.New("not a valid Command")

var _CommandName = "MemoryReadMemoryWriteMemoryFillMultipleMemoryReadMemoryTransfer"

var _CommandMapName = map[Command]string{
	CommandMemoryRead:         _CommandName[0:10],
	CommandMemoryWrite:        _CommandName[10:21],
	CommandMemoryFill:         _CommandName[21:31],
	CommandMultipleMemoryRead: _CommandName[31:49],
	CommandMemoryTransfer:     _CommandName[49:63],
}

// Name is the attribute of Command.
func (x Command) Name() string {
	if v, ok := _CommandMapName[x]; ok {
		return v
	}
	return fmt.Sprintf("Command(%d).Name", x)
}

var _CommandMapMr = map[Command]uint8{
	CommandMemoryRead:         1,
	CommandMemoryWrite:        1,
	CommandMemoryFill:         1,
	CommandMultipleMemoryRead: 1,
	CommandMemoryTransfer:     1,
}

// Mr is the attribute of Command.
func (x Command) Mr() uint8 {
	if v, ok := _CommandMapMr[x]; ok {
		return v
	}
	return 0
}

var _CommandMapSr = map[Command]uint8{
	CommandMemoryRead:         1,
	CommandMemoryWrite:        2,
	CommandMemoryFill:         3,
	CommandMultipleMemoryRead: 4,
	CommandMemoryTransfer:     5,
}

// Sr is the attribute of Command.
func (x Command) Sr() uint8 {
	if v, ok := _CommandMapSr[x]; ok {
		return v
	}
	return 0
}

// Val is the attribute of Command.
func (x Command) Val() int {
	return int(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x Command) IsValid() bool {
	_, ok := _CommandMapName[x]
	return ok
}

// String implements the Stringer interface.
func (x Command) String() string {
	return x.Name()
}

var _CommandNameMap = map[string]Command{
	_CommandName[0:10]:  CommandMemoryRead,
	_CommandName[10:21]: CommandMemoryWrite,
	_CommandName[21:31]: CommandMemoryFill,
	_CommandName[31:49]: CommandMultipleMemoryRead,
	_CommandName[49:63]: CommandMemoryTransfer,
}

// ParseCommand converts a string to a Command.
func ParseCommand(value string) (Command, error) {
	if x, ok := _CommandNameMap[value]; ok {
		return x, nil
	}
	return Command(0), fmt.Errorf("%s is %w", value, ErrInvalidCommand)
}

var ErrInvalidDataType = errors.New("not a valid DataType")

var _DataTypeNameMap = map[string]DataType{
	"Bit":    DataTypeBit,
	"BitFs":  DataTypeBitFs,
	"Word":   DataTypeWord,
	"WordFs": DataTypeWordFs,
	"CF":     DataTypeCF,
	"CFFs":   DataTypeCFFs,
	"PV":     DataTypePV,
}

// Name is the attribute of DataType.
func (x DataType) Name() string {
	if v, ok := _DataTypeNameMap[string(x)]; ok {
		return string(v)
	}
	return fmt.Sprintf("DataType(%s).Name", string(x))
}

// Val is the attribute of DataType.
func (x DataType) Val() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x DataType) IsValid() bool {
	_, ok := _DataTypeNameMap[string(x)]
	return ok
}

// String implements the Stringer interface.
func (x DataType) String() string {
	return x.Name()
}

// ParseDataType converts a string to a DataType.
func ParseDataType(value string) (DataType, error) {
	if x, ok := _DataTypeNameMap[value]; ok {
		return x, nil
	}
	return "", fmt.Errorf("%s is %w", value, ErrInvalidDataType)
}

var ErrInvalidMemoryArea = errors.New("not a valid MemoryArea")

var _MemoryAreaName = "CIOBitWBitHBitABitCIOBitFsWBitFsHBitFsCIOWordWWordHWordAWordCIOWordFsWWordFsHWordFsTBitCBitTBitFsCBitFsTWordCWordDBitDWordIRDR"

var _MemoryAreaMapName = map[MemoryArea]string{
	MemoryAreaCIOBit:    _MemoryAreaName[0:6],
	MemoryAreaWBit:      _MemoryAreaName[6:10],
	MemoryAreaHBit:      _MemoryAreaName[10:14],
	MemoryAreaABit:      _MemoryAreaName[14:18],
	MemoryAreaCIOBitFs:  _MemoryAreaName[18:26],
	MemoryAreaWBitFs:    _MemoryAreaName[26:32],
	MemoryAreaHBitFs:    _MemoryAreaName[32:38],
	MemoryAreaCIOWord:   _MemoryAreaName[38:45],
	MemoryAreaWWord:     _MemoryAreaName[45:50],
	MemoryAreaHWord:     _MemoryAreaName[50:55],
	MemoryAreaAWord:     _MemoryAreaName[55:60],
	MemoryAreaCIOWordFs: _MemoryAreaName[60:69],
	MemoryAreaWWordFs:   _MemoryAreaName[69:76],
	MemoryAreaHWordFs:   _MemoryAreaName[76:83],
	MemoryAreaTBit:      _MemoryAreaName[83:87],
	MemoryAreaCBit:      _MemoryAreaName[87:91],
	MemoryAreaTBitFs:    _MemoryAreaName[91:97],
	MemoryAreaCBitFs:    _MemoryAreaName[97:103],
	MemoryAreaTWord:     _MemoryAreaName[103:108],
	MemoryAreaCWord:     _MemoryAreaName[108:113],
	MemoryAreaDBit:      _MemoryAreaName[113:117],
	MemoryAreaDWord:     _MemoryAreaName[117:122],
	MemoryAreaIR:        _MemoryAreaName[122:124],
	MemoryAreaDR:        _MemoryAreaName[124:126],
}

// Name is the attribute of MemoryArea.
func (x MemoryArea) Name() string {
	if v, ok := _MemoryAreaMapName[x]; ok {
		return v
	}
	return fmt.Sprintf("MemoryArea(%d).Name", x)
}

var _MemoryAreaMapAreaName = map[MemoryArea]string{
	MemoryAreaCIOBit:    "CIO",
	MemoryAreaWBit:      "WR",
	MemoryAreaHBit:      "HR",
	MemoryAreaABit:      "AR",
	MemoryAreaCIOBitFs:  "CIO",
	MemoryAreaWBitFs:    "WR",
	MemoryAreaHBitFs:    "HR",
	MemoryAreaCIOWord:   "CIO",
	MemoryAreaWWord:     "WR",
	MemoryAreaHWord:     "HR",
	MemoryAreaAWord:     "AR",
	MemoryAreaCIOWordFs: "CIO",
	MemoryAreaWWordFs:   "WR",
	MemoryAreaHWordFs:   "HR",
	MemoryAreaTBit:      "TIM",
	MemoryAreaCBit:      "CNT",
	MemoryAreaTBitFs:    "TIM",
	MemoryAreaCBitFs:    "CNT",
	MemoryAreaTWord:     "TIM",
	MemoryAreaCWord:     "CNT",
	MemoryAreaDBit:      "DM",
	MemoryAreaDWord:     "DM",
	MemoryAreaIR:        "IR",
	MemoryAreaDR:        "DR",
}

// AreaName is the attribute of MemoryArea.
func (x MemoryArea) AreaName() string {
	if v, ok := _MemoryAreaMapAreaName[x]; ok {
		return v
	}
	return fmt.Sprintf("MemoryArea(%d).AreaName", x)
}

var _MemoryAreaMapDataType = map[MemoryArea]string{
	MemoryAreaCIOBit:    "Bit",
	MemoryAreaWBit:      "Bit",
	MemoryAreaHBit:      "Bit",
	MemoryAreaABit:      "Bit",
	MemoryAreaCIOBitFs:  "BitFs",
	MemoryAreaWBitFs:    "BitFs",
	MemoryAreaHBitFs:    "BitFs",
	MemoryAreaCIOWord:   "Word",
	MemoryAreaWWord:     "Word",
	MemoryAreaHWord:     "Word",
	MemoryAreaAWord:     "Word",
	MemoryAreaCIOWordFs: "WordFs",
	MemoryAreaWWordFs:   "WordFs",
	MemoryAreaHWordFs:   "WordFs",
	MemoryAreaTBit:      "CF",
	MemoryAreaCBit:      "CF",
	MemoryAreaTBitFs:    "CFFs",
	MemoryAreaCBitFs:    "CFFs",
	MemoryAreaTWord:     "PV",
	MemoryAreaCWord:     "PV",
	MemoryAreaDBit:      "Bit",
	MemoryAreaDWord:     "Word",
	MemoryAreaIR:        "PV",
	MemoryAreaDR:        "PV",
}

// DataType is the attribute of MemoryArea.
func (x MemoryArea) DataType() string {
	if v, ok := _MemoryAreaMapDataType[x]; ok {
		return v
	}
	return fmt.Sprintf("MemoryArea(%d).DataType", x)
}

var _MemoryAreaMapCode = map[MemoryArea]uint8{
	MemoryAreaCIOBit:    48,
	MemoryAreaWBit:      49,
	MemoryAreaHBit:      50,
	MemoryAreaABit:      51,
	MemoryAreaCIOBitFs:  112,
	MemoryAreaWBitFs:    113,
	MemoryAreaHBitFs:    114,
	MemoryAreaCIOWord:   176,
	MemoryAreaWWord:     177,
	MemoryAreaHWord:     178,
	MemoryAreaAWord:     179,
	MemoryAreaCIOWordFs: 240,
	MemoryAreaWWordFs:   241,
	MemoryAreaHWordFs:   242,
	MemoryAreaTBit:      9,
	MemoryAreaCBit:      9,
	MemoryAreaTBitFs:    73,
	MemoryAreaCBitFs:    73,
	MemoryAreaTWord:     137,
	MemoryAreaCWord:     137,
	MemoryAreaDBit:      2,
	MemoryAreaDWord:     130,
	MemoryAreaIR:        220,
	MemoryAreaDR:        188,
}

// Code is the attribute of MemoryArea.
func (x MemoryArea) Code() uint8 {
	if v, ok := _MemoryAreaMapCode[x]; ok {
		return v
	}
	return 0
}

var _MemoryAreaMapMax = map[MemoryArea]uint16{
	MemoryAreaCIOBit:    6143,
	MemoryAreaWBit:      511,
	MemoryAreaHBit:      511,
	MemoryAreaABit:      959,
	MemoryAreaCIOBitFs:  6143,
	MemoryAreaWBitFs:    511,
	MemoryAreaHBitFs:    511,
	MemoryAreaCIOWord:   6143,
	MemoryAreaWWord:     511,
	MemoryAreaHWord:     511,
	MemoryAreaAWord:     959,
	MemoryAreaCIOWordFs: 6143,
	MemoryAreaWWordFs:   511,
	MemoryAreaHWordFs:   511,
	MemoryAreaTBit:      4095,
	MemoryAreaCBit:      4095,
	MemoryAreaTBitFs:    4095,
	MemoryAreaCBitFs:    4095,
	MemoryAreaTWord:     4095,
	MemoryAreaCWord:     4095,
	MemoryAreaDBit:      32767,
	MemoryAreaDWord:     32767,
	MemoryAreaIR:        15,
	MemoryAreaDR:        15,
}

// Max is the attribute of MemoryArea.
func (x MemoryArea) Max() uint16 {
	if v, ok := _MemoryAreaMapMax[x]; ok {
		return v
	}
	return 0
}

var _MemoryAreaMapOffset = map[MemoryArea]uint16{
	MemoryAreaCIOBit:    0,
	MemoryAreaWBit:      0,
	MemoryAreaHBit:      0,
	MemoryAreaABit:      0,
	MemoryAreaCIOBitFs:  0,
	MemoryAreaWBitFs:    0,
	MemoryAreaHBitFs:    0,
	MemoryAreaCIOWord:   0,
	MemoryAreaWWord:     0,
	MemoryAreaHWord:     0,
	MemoryAreaAWord:     0,
	MemoryAreaCIOWordFs: 0,
	MemoryAreaWWordFs:   0,
	MemoryAreaHWordFs:   0,
	MemoryAreaTBit:      0,
	MemoryAreaCBit:      32768,
	MemoryAreaTBitFs:    0,
	MemoryAreaCBitFs:    32768,
	MemoryAreaTWord:     0,
	MemoryAreaCWord:     32768,
	MemoryAreaDBit:      0,
	MemoryAreaDWord:     0,
	MemoryAreaIR:        256,
	MemoryAreaDR:        512,
}

// Offset is the attribute of MemoryArea.
func (x MemoryArea) Offset() uint16 {
	if v, ok := _MemoryAreaMapOffset[x]; ok {
		return v
	}
	return 0
}

var _MemoryAreaMapOldCode = map[MemoryArea]uint8{
	MemoryAreaCIOBit:    0,
	MemoryAreaWBit:      0,
	MemoryAreaHBit:      0,
	MemoryAreaABit:      0,
	MemoryAreaCIOBitFs:  64,
	MemoryAreaWBitFs:    0,
	MemoryAreaHBitFs:    0,
	MemoryAreaCIOWord:   128,
	MemoryAreaWWord:     0,
	MemoryAreaHWord:     0,
	MemoryAreaAWord:     128,
	MemoryAreaCIOWordFs: 192,
	MemoryAreaWWordFs:   0,
	MemoryAreaHWordFs:   0,
	MemoryAreaTBit:      1,
	MemoryAreaCBit:      1,
	MemoryAreaTBitFs:    65,
	MemoryAreaCBitFs:    65,
	MemoryAreaTWord:     129,
	MemoryAreaCWord:     129,
	MemoryAreaDBit:      0,
	MemoryAreaDWord:     130,
	MemoryAreaIR:        0,
	MemoryAreaDR:        156,
}

// OldCode is the attribute of MemoryArea.
func (x MemoryArea) OldCode() uint8 {
	if v, ok := _MemoryAreaMapOldCode[x]; ok {
		return v
	}
	return 0
}

var _MemoryAreaMapOldMax = map[MemoryArea]uint16{
	MemoryAreaCIOBit:    2555,
	MemoryAreaWBit:      65535,
	MemoryAreaHBit:      65535,
	MemoryAreaABit:      959,
	MemoryAreaCIOBitFs:  2555,
	MemoryAreaWBitFs:    65535,
	MemoryAreaHBitFs:    65535,
	MemoryAreaCIOWord:   2555,
	MemoryAreaWWord:     65535,
	MemoryAreaHWord:     65535,
	MemoryAreaAWord:     959,
	MemoryAreaCIOWordFs: 2555,
	MemoryAreaWWordFs:   65535,
	MemoryAreaHWordFs:   65535,
	MemoryAreaTBit:      2047,
	MemoryAreaCBit:      2047,
	MemoryAreaTBitFs:    2047,
	MemoryAreaCBitFs:    2047,
	MemoryAreaTWord:     2047,
	MemoryAreaCWord:     2047,
	MemoryAreaDBit:      65535,
	MemoryAreaDWord:     32767,
	MemoryAreaIR:        65535,
	MemoryAreaDR:        2,
}

// OldMax is the attribute of MemoryArea.
func (x MemoryArea) OldMax() uint16 {
	if v, ok := _MemoryAreaMapOldMax[x]; ok {
		return v
	}
	return 0
}

var _MemoryAreaMapOldOffset = map[MemoryArea]uint16{
	MemoryAreaCIOBit:    0,
	MemoryAreaWBit:      65535,
	MemoryAreaHBit:      65535,
	MemoryAreaABit:      2816,
	MemoryAreaCIOBitFs:  0,
	MemoryAreaWBitFs:    65535,
	MemoryAreaHBitFs:    65535,
	MemoryAreaCIOWord:   0,
	MemoryAreaWWord:     65535,
	MemoryAreaHWord:     65535,
	MemoryAreaAWord:     2816,
	MemoryAreaCIOWordFs: 0,
	MemoryAreaWWordFs:   65535,
	MemoryAreaHWordFs:   65535,
	MemoryAreaTBit:      0,
	MemoryAreaCBit:      2048,
	MemoryAreaTBitFs:    0,
	MemoryAreaCBitFs:    2048,
	MemoryAreaTWord:     0,
	MemoryAreaCWord:     2048,
	MemoryAreaDBit:      65535,
	MemoryAreaDWord:     0,
	MemoryAreaIR:        65535,
	MemoryAreaDR:        3,
}

// OldOffset is the attribute of MemoryArea.
func (x MemoryArea) OldOffset() uint16 {
	if v, ok := _MemoryAreaMapOldOffset[x]; ok {
		return v
	}
	return 0
}

var _MemoryAreaMapSize = map[MemoryArea]int{
	MemoryAreaCIOBit:    1,
	MemoryAreaWBit:      1,
	MemoryAreaHBit:      1,
	MemoryAreaABit:      1,
	MemoryAreaCIOBitFs:  1,
	MemoryAreaWBitFs:    1,
	MemoryAreaHBitFs:    1,
	MemoryAreaCIOWord:   2,
	MemoryAreaWWord:     2,
	MemoryAreaHWord:     2,
	MemoryAreaAWord:     2,
	MemoryAreaCIOWordFs: 4,
	MemoryAreaWWordFs:   4,
	MemoryAreaHWordFs:   4,
	MemoryAreaTBit:      1,
	MemoryAreaCBit:      1,
	MemoryAreaTBitFs:    1,
	MemoryAreaCBitFs:    1,
	MemoryAreaTWord:     2,
	MemoryAreaCWord:     2,
	MemoryAreaDBit:      1,
	MemoryAreaDWord:     2,
	MemoryAreaIR:        4,
	MemoryAreaDR:        2,
}

// Size is the attribute of MemoryArea.
func (x MemoryArea) Size() int {
	if v, ok := _MemoryAreaMapSize[x]; ok {
		return v
	}
	return 0
}

// Val is the attribute of MemoryArea.
func (x MemoryArea) Val() uint8 {
	return uint8(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x MemoryArea) IsValid() bool {
	_, ok := _MemoryAreaMapName[x]
	return ok
}

// String implements the Stringer interface.
func (x MemoryArea) String() string {
	return x.Name()
}

var _MemoryAreaNameMap = map[string]MemoryArea{
	_MemoryAreaName[0:6]:     MemoryAreaCIOBit,
	_MemoryAreaName[6:10]:    MemoryAreaWBit,
	_MemoryAreaName[10:14]:   MemoryAreaHBit,
	_MemoryAreaName[14:18]:   MemoryAreaABit,
	_MemoryAreaName[18:26]:   MemoryAreaCIOBitFs,
	_MemoryAreaName[26:32]:   MemoryAreaWBitFs,
	_MemoryAreaName[32:38]:   MemoryAreaHBitFs,
	_MemoryAreaName[38:45]:   MemoryAreaCIOWord,
	_MemoryAreaName[45:50]:   MemoryAreaWWord,
	_MemoryAreaName[50:55]:   MemoryAreaHWord,
	_MemoryAreaName[55:60]:   MemoryAreaAWord,
	_MemoryAreaName[60:69]:   MemoryAreaCIOWordFs,
	_MemoryAreaName[69:76]:   MemoryAreaWWordFs,
	_MemoryAreaName[76:83]:   MemoryAreaHWordFs,
	_MemoryAreaName[83:87]:   MemoryAreaTBit,
	_MemoryAreaName[87:91]:   MemoryAreaCBit,
	_MemoryAreaName[91:97]:   MemoryAreaTBitFs,
	_MemoryAreaName[97:103]:  MemoryAreaCBitFs,
	_MemoryAreaName[103:108]: MemoryAreaTWord,
	_MemoryAreaName[108:113]: MemoryAreaCWord,
	_MemoryAreaName[113:117]: MemoryAreaDBit,
	_MemoryAreaName[117:122]: MemoryAreaDWord,
	_MemoryAreaName[122:124]: MemoryAreaIR,
	_MemoryAreaName[124:126]: MemoryAreaDR,
}

// ParseMemoryArea converts a string to a MemoryArea.
func ParseMemoryArea(value string) (MemoryArea, error) {
	if x, ok := _MemoryAreaNameMap[value]; ok {
		return x, nil
	}
	return MemoryArea(0), fmt.Errorf("%s is %w", value, ErrInvalidMemoryArea)
}

var ErrInvalidPlcType = errors.New("not a valid PlcType")

var _PlcTypeName = "NewOld"

var _PlcTypeMapName = map[PlcType]string{
	PlcTypeNew: _PlcTypeName[0:3],
	PlcTypeOld: _PlcTypeName[3:6],
}

// Name is the attribute of PlcType.
func (x PlcType) Name() string {
	if v, ok := _PlcTypeMapName[x]; ok {
		return v
	}
	return fmt.Sprintf("PlcType(%d).Name", x)
}

var _PlcTypeMapDescription = map[PlcType]string{
	PlcTypeNew: "CS/CJ/CP/NSJ-series",
	PlcTypeOld: "CVM1/CV-series",
}

// Description is the attribute of PlcType.
func (x PlcType) Description() string {
	if v, ok := _PlcTypeMapDescription[x]; ok {
		return v
	}
	return fmt.Sprintf("PlcType(%d).Description", x)
}

// Val is the attribute of PlcType.
func (x PlcType) Val() int {
	return int(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x PlcType) IsValid() bool {
	_, ok := _PlcTypeMapName[x]
	return ok
}

// String implements the Stringer interface.
func (x PlcType) String() string {
	return x.Name()
}

var _PlcTypeNameMap = map[string]PlcType{
	_PlcTypeName[0:3]: PlcTypeNew,
	_PlcTypeName[3:6]: PlcTypeOld,
}

// ParsePlcType converts a string to a PlcType.
func ParsePlcType(value string) (PlcType, error) {
	if x, ok := _PlcTypeNameMap[value]; ok {
		return x, nil
	}
	return PlcType(0), fmt.Errorf("%s is %w", value, ErrInvalidPlcType)
}
