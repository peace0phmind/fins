// Code generated by https://github.com/expgo/ag DO NOT EDIT.
// Plugins:
//   - github.com/expgo/enum

package fins

import (
	"errors"
	"fmt"
	"strings"
)

const (
	// AreaCIO is an Area of type CIO.
	AreaCIO Area = "CIO"
	// AreaWR is an Area of type WR.
	AreaWR Area = "WR"
	// AreaHR is an Area of type HR.
	AreaHR Area = "HR"
	// AreaAR is an Area of type AR.
	AreaAR Area = "AR"
	// AreaTIM is an Area of type TIM.
	AreaTIM Area = "TIM"
	// AreaCNT is an Area of type CNT.
	AreaCNT Area = "CNT"
	// AreaDM is an Area of type DM.
	AreaDM Area = "DM"
	// AreaIR is an Area of type IR.
	AreaIR Area = "IR"
	// AreaDR is an Area of type DR.
	AreaDR Area = "DR"
)

const (
	// CommandMemoryRead is a Command of type MemoryRead.
	CommandMemoryRead Command = iota
	// CommandMemoryWrite is a Command of type MemoryWrite.
	CommandMemoryWrite
	// CommandMemoryFill is a Command of type MemoryFill.
	CommandMemoryFill
	// CommandMultipleMemoryRead is a Command of type MultipleMemoryRead.
	CommandMultipleMemoryRead
	// CommandMemoryTransfer is a Command of type MemoryTransfer.
	CommandMemoryTransfer
)

const (
	// DataClassCommand is a DataClass of type Command.
	DataClassCommand DataClass = iota
	// DataClassResponse is a DataClass of type Response.
	DataClassResponse
)

const (
	// DataTypeBit is a DataType of type Bit.
	DataTypeBit DataType = "Bit"
	// DataTypeBitFs is a DataType of type BitFs.
	DataTypeBitFs DataType = "BitFs"
	// DataTypeWord is a DataType of type Word.
	DataTypeWord DataType = "Word"
	// DataTypeWordFs is a DataType of type WordFs.
	DataTypeWordFs DataType = "WordFs"
	// DataTypeCF is a DataType of type CF.
	DataTypeCF DataType = "CF"
	// DataTypeCFFs is a DataType of type CFFs.
	DataTypeCFFs DataType = "CFFs"
	// DataTypePV is a DataType of type PV.
	DataTypePV DataType = "PV"
)

const (
	// MCNormalCompletion is a MC of type NormalCompletion.
	MCNormalCompletion MC = 0
	// MCLocalNodeError is a MC of type LocalNodeError.
	MCLocalNodeError MC = 1
	// MCDestinationNodeError is a MC of type DestinationNodeError.
	MCDestinationNodeError MC = 2
	// MCControllerError is a MC of type ControllerError.
	MCControllerError MC = 3
	// MCServiceUnsupported is a MC of type ServiceUnsupported.
	MCServiceUnsupported MC = 4
	// MCRoutingTableError is a MC of type RoutingTableError.
	MCRoutingTableError MC = 5
	// MCCommandFormatError is a MC of type CommandFormatError.
	MCCommandFormatError MC = 16
	// MCParameterError is a MC of type ParameterError.
	MCParameterError MC = 17
	// MCReadNotPossible is a MC of type ReadNotPossible.
	MCReadNotPossible MC = 32
	// MCWriteNotPossible is a MC of type WriteNotPossible.
	MCWriteNotPossible MC = 33
	// MCNotExecutableInCurrentMode is a MC of type NotExecutableInCurrentMode.
	MCNotExecutableInCurrentMode MC = 34
	// MCNoSuchDevice is a MC of type NoSuchDevice.
	MCNoSuchDevice MC = 35
	// MCCannotStartStop is a MC of type CannotStartStop.
	MCCannotStartStop MC = 36
	// MCUnitError is a MC of type UnitError.
	MCUnitError MC = 37
	// MCCommandError is a MC of type CommandError.
	MCCommandError MC = 38
	// MCAccessRightError is a MC of type AccessRightError.
	MCAccessRightError MC = 48
	// MCAbort is a MC of type Abort.
	MCAbort MC = 64
)

const (
	// MemoryAreaCIOBit is a MemoryArea of type CIOBit.
	MemoryAreaCIOBit MemoryArea = "CIOBit" // CIO Area Bit
	// MemoryAreaWRBit is a MemoryArea of type WRBit.
	MemoryAreaWRBit MemoryArea = "WRBit" // Work Area Bit
	// MemoryAreaHRBit is a MemoryArea of type HRBit.
	MemoryAreaHRBit MemoryArea = "HRBit" // Holding Bit Area Bit
	// MemoryAreaARBit is a MemoryArea of type ARBit.
	MemoryAreaARBit MemoryArea = "ARBit" // Auxiliary Bit Area Bit
	// MemoryAreaCIOBitFs is a MemoryArea of type CIOBitFs.
	MemoryAreaCIOBitFs MemoryArea = "CIOBitFs" // CIO Area Bit with forced status
	// MemoryAreaWRBitFs is a MemoryArea of type WRBitFs.
	MemoryAreaWRBitFs MemoryArea = "WRBitFs" // Work Area Bit with forced status
	// MemoryAreaHRBitFs is a MemoryArea of type HRBitFs.
	MemoryAreaHRBitFs MemoryArea = "HRBitFs" // Holding Bit Area Bit with forced status
	// MemoryAreaCIOWord is a MemoryArea of type CIOWord.
	MemoryAreaCIOWord MemoryArea = "CIOWord" // CIO Area Word
	// MemoryAreaWRWord is a MemoryArea of type WRWord.
	MemoryAreaWRWord MemoryArea = "WRWord" // Work Area Word
	// MemoryAreaHRWord is a MemoryArea of type HRWord.
	MemoryAreaHRWord MemoryArea = "HRWord" // Holding Bit Area Word
	// MemoryAreaARWord is a MemoryArea of type ARWord.
	MemoryAreaARWord MemoryArea = "ARWord" // Auxiliary Bit Area Word
	// MemoryAreaCIOWordFs is a MemoryArea of type CIOWordFs.
	MemoryAreaCIOWordFs MemoryArea = "CIOWordFs" // CIO Area Word with forced status
	// MemoryAreaWRWordFs is a MemoryArea of type WRWordFs.
	MemoryAreaWRWordFs MemoryArea = "WRWordFs" // Work Area Word with forced status
	// MemoryAreaHRWordFs is a MemoryArea of type HRWordFs.
	MemoryAreaHRWordFs MemoryArea = "HRWordFs" // Holding Bit Area Word with forced status
	// MemoryAreaTIMCF is a MemoryArea of type TIMCF.
	MemoryAreaTIMCF MemoryArea = "TIMCF" // Timer Area
	// MemoryAreaCNTCF is a MemoryArea of type CNTCF.
	MemoryAreaCNTCF MemoryArea = "CNTCF" // Counter Area
	// MemoryAreaTIMCFFs is a MemoryArea of type TIMCFFs.
	MemoryAreaTIMCFFs MemoryArea = "TIMCFFs" // Timer Area with forced status
	// MemoryAreaCNTCFFs is a MemoryArea of type CNTCFFs.
	MemoryAreaCNTCFFs MemoryArea = "CNTCFFs" // Counter Area with forced status
	// MemoryAreaTIMPV is a MemoryArea of type TIMPV.
	MemoryAreaTIMPV MemoryArea = "TIMPV" // Timer Area
	// MemoryAreaCNTPV is a MemoryArea of type CNTPV.
	MemoryAreaCNTPV MemoryArea = "CNTPV" // Counter Area
	// MemoryAreaDMBit is a MemoryArea of type DMBit.
	MemoryAreaDMBit MemoryArea = "DMBit" // DM Area
	// MemoryAreaDMWord is a MemoryArea of type DMWord.
	MemoryAreaDMWord MemoryArea = "DMWord" // DM Area
	// MemoryAreaIRPV is a MemoryArea of type IRPV.
	MemoryAreaIRPV MemoryArea = "IRPV" // Index Register
	// MemoryAreaDRPV is a MemoryArea of type DRPV.
	MemoryAreaDRPV MemoryArea = "DRPV" // Data Register
)

const (
	// PlcTypeNew is a PlcType of type New.
	PlcTypeNew PlcType = iota
	// PlcTypeOld is a PlcType of type Old.
	PlcTypeOld
)

const (
	// StateUnknown is a State of type Unknown.
	StateUnknown State = iota
	// StateConnecting is a State of type Connecting.
	StateConnecting
	// StateConnected is a State of type Connected.
	StateConnected
	// StateDisconnected is a State of type Disconnected.
	StateDisconnected
	// StateConnectClosed is a State of type ConnectClosed.
	StateConnectClosed
)

const (
	// TcpCommandFrameSend is a TcpCommand of type FrameSend.
	TcpCommandFrameSend TcpCommand = 2
)

const (
	// TransTypeTcp is a TransType of type Tcp.
	TransTypeTcp TransType = iota
	// TransTypeUdp is a TransType of type Udp.
	TransTypeUdp
)

var ErrInvalidArea = errors.New("not a valid Area")

var _AreaNameMap = map[string]Area{
	"CIO": AreaCIO,
	"cio": AreaCIO,
	"WR":  AreaWR,
	"wr":  AreaWR,
	"HR":  AreaHR,
	"hr":  AreaHR,
	"AR":  AreaAR,
	"ar":  AreaAR,
	"TIM": AreaTIM,
	"tim": AreaTIM,
	"CNT": AreaCNT,
	"cnt": AreaCNT,
	"DM":  AreaDM,
	"dm":  AreaDM,
	"IR":  AreaIR,
	"ir":  AreaIR,
	"DR":  AreaDR,
	"dr":  AreaDR,
}

// Name is the attribute of Area.
func (x Area) Name() string {
	if v, ok := _AreaNameMap[string(x)]; ok {
		return string(v)
	}
	return fmt.Sprintf("Area(%s).Name", string(x))
}

// Val is the attribute of Area.
func (x Area) Val() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x Area) IsValid() bool {
	_, ok := _AreaNameMap[string(x)]
	return ok
}

// String implements the Stringer interface.
func (x Area) String() string {
	return x.Name()
}

// ParseArea converts a string to an Area.
func ParseArea(value string) (Area, error) {
	if x, ok := _AreaNameMap[value]; ok {
		return x, nil
	}
	if x, ok := _AreaNameMap[strings.ToLower(value)]; ok {
		return x, nil
	}
	return "", fmt.Errorf("%s is %w", value, ErrInvalidArea)
}

var ErrInvalidCommand = errors.New("not a valid Command")

var _CommandName = "MemoryReadMemoryWriteMemoryFillMultipleMemoryReadMemoryTransfer"

var _CommandMapName = map[Command]string{
	CommandMemoryRead:         _CommandName[0:10],
	CommandMemoryWrite:        _CommandName[10:21],
	CommandMemoryFill:         _CommandName[21:31],
	CommandMultipleMemoryRead: _CommandName[31:49],
	CommandMemoryTransfer:     _CommandName[49:63],
}

// Name is the attribute of Command.
func (x Command) Name() string {
	if v, ok := _CommandMapName[x]; ok {
		return v
	}
	return fmt.Sprintf("Command(%d).Name", x)
}

var _CommandMapMr = map[Command]uint8{
	CommandMemoryRead:         1,
	CommandMemoryWrite:        1,
	CommandMemoryFill:         1,
	CommandMultipleMemoryRead: 1,
	CommandMemoryTransfer:     1,
}

// Mr is the attribute of Command.
func (x Command) Mr() uint8 {
	if v, ok := _CommandMapMr[x]; ok {
		return v
	}
	return 0
}

var _CommandMapSr = map[Command]uint8{
	CommandMemoryRead:         1,
	CommandMemoryWrite:        2,
	CommandMemoryFill:         3,
	CommandMultipleMemoryRead: 4,
	CommandMemoryTransfer:     5,
}

// Sr is the attribute of Command.
func (x Command) Sr() uint8 {
	if v, ok := _CommandMapSr[x]; ok {
		return v
	}
	return 0
}

// Val is the attribute of Command.
func (x Command) Val() int {
	return int(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x Command) IsValid() bool {
	_, ok := _CommandMapName[x]
	return ok
}

// String implements the Stringer interface.
func (x Command) String() string {
	return x.Name()
}

var _CommandNameMap = map[string]Command{
	_CommandName[0:10]:  CommandMemoryRead,
	_CommandName[10:21]: CommandMemoryWrite,
	_CommandName[21:31]: CommandMemoryFill,
	_CommandName[31:49]: CommandMultipleMemoryRead,
	_CommandName[49:63]: CommandMemoryTransfer,
}

// ParseCommand converts a string to a Command.
func ParseCommand(value string) (Command, error) {
	if x, ok := _CommandNameMap[value]; ok {
		return x, nil
	}
	return Command(0), fmt.Errorf("%s is %w", value, ErrInvalidCommand)
}

var ErrInvalidDataClass = errors.New("not a valid DataClass")

var _DataClassName = "CommandResponse"

var _DataClassMapName = map[DataClass]string{
	DataClassCommand:  _DataClassName[0:7],
	DataClassResponse: _DataClassName[7:15],
}

// Name is the attribute of DataClass.
func (x DataClass) Name() string {
	if v, ok := _DataClassMapName[x]; ok {
		return v
	}
	return fmt.Sprintf("DataClass(%d).Name", x)
}

// Val is the attribute of DataClass.
func (x DataClass) Val() int {
	return int(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x DataClass) IsValid() bool {
	_, ok := _DataClassMapName[x]
	return ok
}

// String implements the Stringer interface.
func (x DataClass) String() string {
	return x.Name()
}

var _DataClassNameMap = map[string]DataClass{
	_DataClassName[0:7]:  DataClassCommand,
	_DataClassName[7:15]: DataClassResponse,
}

// ParseDataClass converts a string to a DataClass.
func ParseDataClass(value string) (DataClass, error) {
	if x, ok := _DataClassNameMap[value]; ok {
		return x, nil
	}
	return DataClass(0), fmt.Errorf("%s is %w", value, ErrInvalidDataClass)
}

var ErrInvalidDataType = errors.New("not a valid DataType")

var _DataTypeNameMap = map[string]DataType{
	"Bit":    DataTypeBit,
	"BitFs":  DataTypeBitFs,
	"Word":   DataTypeWord,
	"WordFs": DataTypeWordFs,
	"CF":     DataTypeCF,
	"CFFs":   DataTypeCFFs,
	"PV":     DataTypePV,
}

// Name is the attribute of DataType.
func (x DataType) Name() string {
	if v, ok := _DataTypeNameMap[string(x)]; ok {
		return string(v)
	}
	return fmt.Sprintf("DataType(%s).Name", string(x))
}

// Val is the attribute of DataType.
func (x DataType) Val() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x DataType) IsValid() bool {
	_, ok := _DataTypeNameMap[string(x)]
	return ok
}

// String implements the Stringer interface.
func (x DataType) String() string {
	return x.Name()
}

// ParseDataType converts a string to a DataType.
func ParseDataType(value string) (DataType, error) {
	if x, ok := _DataTypeNameMap[value]; ok {
		return x, nil
	}
	return "", fmt.Errorf("%s is %w", value, ErrInvalidDataType)
}

var ErrInvalidMC = errors.New("not a valid MC")

var _MCName = "NormalCompletionLocalNodeErrorDestinationNodeErrorControllerErrorServiceUnsupportedRoutingTableErrorCommandFormatErrorParameterErrorReadNotPossibleWriteNotPossibleNotExecutableInCurrentModeNoSuchDeviceCannotStartStopUnitErrorCommandErrorAccessRightErrorAbort"

var _MCMapName = map[MC]string{
	MCNormalCompletion:           _MCName[0:16],
	MCLocalNodeError:             _MCName[16:30],
	MCDestinationNodeError:       _MCName[30:50],
	MCControllerError:            _MCName[50:65],
	MCServiceUnsupported:         _MCName[65:83],
	MCRoutingTableError:          _MCName[83:100],
	MCCommandFormatError:         _MCName[100:118],
	MCParameterError:             _MCName[118:132],
	MCReadNotPossible:            _MCName[132:147],
	MCWriteNotPossible:           _MCName[147:163],
	MCNotExecutableInCurrentMode: _MCName[163:189],
	MCNoSuchDevice:               _MCName[189:201],
	MCCannotStartStop:            _MCName[201:216],
	MCUnitError:                  _MCName[216:225],
	MCCommandError:               _MCName[225:237],
	MCAccessRightError:           _MCName[237:253],
	MCAbort:                      _MCName[253:258],
}

// Name is the attribute of MC.
func (x MC) Name() string {
	if v, ok := _MCMapName[x]; ok {
		return v
	}
	return fmt.Sprintf("MC(%d).Name", x)
}

// Val is the attribute of MC.
func (x MC) Val() uint8 {
	return uint8(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x MC) IsValid() bool {
	_, ok := _MCMapName[x]
	return ok
}

// String implements the Stringer interface.
func (x MC) String() string {
	return x.Name()
}

var _MCNameMap = map[string]MC{
	_MCName[0:16]:    MCNormalCompletion,
	_MCName[16:30]:   MCLocalNodeError,
	_MCName[30:50]:   MCDestinationNodeError,
	_MCName[50:65]:   MCControllerError,
	_MCName[65:83]:   MCServiceUnsupported,
	_MCName[83:100]:  MCRoutingTableError,
	_MCName[100:118]: MCCommandFormatError,
	_MCName[118:132]: MCParameterError,
	_MCName[132:147]: MCReadNotPossible,
	_MCName[147:163]: MCWriteNotPossible,
	_MCName[163:189]: MCNotExecutableInCurrentMode,
	_MCName[189:201]: MCNoSuchDevice,
	_MCName[201:216]: MCCannotStartStop,
	_MCName[216:225]: MCUnitError,
	_MCName[225:237]: MCCommandError,
	_MCName[237:253]: MCAccessRightError,
	_MCName[253:258]: MCAbort,
}

// ParseMC converts a string to a MC.
func ParseMC(value string) (MC, error) {
	if x, ok := _MCNameMap[value]; ok {
		return x, nil
	}
	return MC(0), fmt.Errorf("%s is %w", value, ErrInvalidMC)
}

var ErrInvalidMemoryArea = errors.New("not a valid MemoryArea")

var _MemoryAreaNameMap = map[string]MemoryArea{
	"CIOBit":    MemoryAreaCIOBit,
	"ciobit":    MemoryAreaCIOBit,
	"WRBit":     MemoryAreaWRBit,
	"wrbit":     MemoryAreaWRBit,
	"HRBit":     MemoryAreaHRBit,
	"hrbit":     MemoryAreaHRBit,
	"ARBit":     MemoryAreaARBit,
	"arbit":     MemoryAreaARBit,
	"CIOBitFs":  MemoryAreaCIOBitFs,
	"ciobitfs":  MemoryAreaCIOBitFs,
	"WRBitFs":   MemoryAreaWRBitFs,
	"wrbitfs":   MemoryAreaWRBitFs,
	"HRBitFs":   MemoryAreaHRBitFs,
	"hrbitfs":   MemoryAreaHRBitFs,
	"CIOWord":   MemoryAreaCIOWord,
	"cioword":   MemoryAreaCIOWord,
	"WRWord":    MemoryAreaWRWord,
	"wrword":    MemoryAreaWRWord,
	"HRWord":    MemoryAreaHRWord,
	"hrword":    MemoryAreaHRWord,
	"ARWord":    MemoryAreaARWord,
	"arword":    MemoryAreaARWord,
	"CIOWordFs": MemoryAreaCIOWordFs,
	"ciowordfs": MemoryAreaCIOWordFs,
	"WRWordFs":  MemoryAreaWRWordFs,
	"wrwordfs":  MemoryAreaWRWordFs,
	"HRWordFs":  MemoryAreaHRWordFs,
	"hrwordfs":  MemoryAreaHRWordFs,
	"TIMCF":     MemoryAreaTIMCF,
	"timcf":     MemoryAreaTIMCF,
	"CNTCF":     MemoryAreaCNTCF,
	"cntcf":     MemoryAreaCNTCF,
	"TIMCFFs":   MemoryAreaTIMCFFs,
	"timcffs":   MemoryAreaTIMCFFs,
	"CNTCFFs":   MemoryAreaCNTCFFs,
	"cntcffs":   MemoryAreaCNTCFFs,
	"TIMPV":     MemoryAreaTIMPV,
	"timpv":     MemoryAreaTIMPV,
	"CNTPV":     MemoryAreaCNTPV,
	"cntpv":     MemoryAreaCNTPV,
	"DMBit":     MemoryAreaDMBit,
	"dmbit":     MemoryAreaDMBit,
	"DMWord":    MemoryAreaDMWord,
	"dmword":    MemoryAreaDMWord,
	"IRPV":      MemoryAreaIRPV,
	"irpv":      MemoryAreaIRPV,
	"DRPV":      MemoryAreaDRPV,
	"drpv":      MemoryAreaDRPV,
}

// Name is the attribute of MemoryArea.
func (x MemoryArea) Name() string {
	if v, ok := _MemoryAreaNameMap[string(x)]; ok {
		return string(v)
	}
	return fmt.Sprintf("MemoryArea(%s).Name", string(x))
}

var _MemoryAreaMapAreaName = map[MemoryArea]string{
	MemoryAreaCIOBit:    "CIO",
	MemoryAreaWRBit:     "WR",
	MemoryAreaHRBit:     "HR",
	MemoryAreaARBit:     "AR",
	MemoryAreaCIOBitFs:  "CIO",
	MemoryAreaWRBitFs:   "WR",
	MemoryAreaHRBitFs:   "HR",
	MemoryAreaCIOWord:   "CIO",
	MemoryAreaWRWord:    "WR",
	MemoryAreaHRWord:    "HR",
	MemoryAreaARWord:    "AR",
	MemoryAreaCIOWordFs: "CIO",
	MemoryAreaWRWordFs:  "WR",
	MemoryAreaHRWordFs:  "HR",
	MemoryAreaTIMCF:     "TIM",
	MemoryAreaCNTCF:     "CNT",
	MemoryAreaTIMCFFs:   "TIM",
	MemoryAreaCNTCFFs:   "CNT",
	MemoryAreaTIMPV:     "TIM",
	MemoryAreaCNTPV:     "CNT",
	MemoryAreaDMBit:     "DM",
	MemoryAreaDMWord:    "DM",
	MemoryAreaIRPV:      "IR",
	MemoryAreaDRPV:      "DR",
}

// AreaName is the attribute of MemoryArea.
func (x MemoryArea) AreaName() string {
	if v, ok := _MemoryAreaMapAreaName[x]; ok {
		return v
	}
	return fmt.Sprintf("MemoryArea(%s).AreaName", string(x))
}

var _MemoryAreaMapDataType = map[MemoryArea]string{
	MemoryAreaCIOBit:    "Bit",
	MemoryAreaWRBit:     "Bit",
	MemoryAreaHRBit:     "Bit",
	MemoryAreaARBit:     "Bit",
	MemoryAreaCIOBitFs:  "BitFs",
	MemoryAreaWRBitFs:   "BitFs",
	MemoryAreaHRBitFs:   "BitFs",
	MemoryAreaCIOWord:   "Word",
	MemoryAreaWRWord:    "Word",
	MemoryAreaHRWord:    "Word",
	MemoryAreaARWord:    "Word",
	MemoryAreaCIOWordFs: "WordFs",
	MemoryAreaWRWordFs:  "WordFs",
	MemoryAreaHRWordFs:  "WordFs",
	MemoryAreaTIMCF:     "CF",
	MemoryAreaCNTCF:     "CF",
	MemoryAreaTIMCFFs:   "CFFs",
	MemoryAreaCNTCFFs:   "CFFs",
	MemoryAreaTIMPV:     "PV",
	MemoryAreaCNTPV:     "PV",
	MemoryAreaDMBit:     "Bit",
	MemoryAreaDMWord:    "Word",
	MemoryAreaIRPV:      "PV",
	MemoryAreaDRPV:      "PV",
}

// DataType is the attribute of MemoryArea.
func (x MemoryArea) DataType() string {
	if v, ok := _MemoryAreaMapDataType[x]; ok {
		return v
	}
	return fmt.Sprintf("MemoryArea(%s).DataType", string(x))
}

var _MemoryAreaMapCode = map[MemoryArea]uint8{
	MemoryAreaCIOBit:    48,
	MemoryAreaWRBit:     49,
	MemoryAreaHRBit:     50,
	MemoryAreaARBit:     51,
	MemoryAreaCIOBitFs:  112,
	MemoryAreaWRBitFs:   113,
	MemoryAreaHRBitFs:   114,
	MemoryAreaCIOWord:   176,
	MemoryAreaWRWord:    177,
	MemoryAreaHRWord:    178,
	MemoryAreaARWord:    179,
	MemoryAreaCIOWordFs: 240,
	MemoryAreaWRWordFs:  241,
	MemoryAreaHRWordFs:  242,
	MemoryAreaTIMCF:     9,
	MemoryAreaCNTCF:     9,
	MemoryAreaTIMCFFs:   73,
	MemoryAreaCNTCFFs:   73,
	MemoryAreaTIMPV:     137,
	MemoryAreaCNTPV:     137,
	MemoryAreaDMBit:     2,
	MemoryAreaDMWord:    130,
	MemoryAreaIRPV:      220,
	MemoryAreaDRPV:      188,
}

// Code is the attribute of MemoryArea.
func (x MemoryArea) Code() uint8 {
	if v, ok := _MemoryAreaMapCode[x]; ok {
		return v
	}
	return 0
}

var _MemoryAreaMapMax = map[MemoryArea]uint16{
	MemoryAreaCIOBit:    6143,
	MemoryAreaWRBit:     511,
	MemoryAreaHRBit:     511,
	MemoryAreaARBit:     959,
	MemoryAreaCIOBitFs:  6143,
	MemoryAreaWRBitFs:   511,
	MemoryAreaHRBitFs:   511,
	MemoryAreaCIOWord:   6143,
	MemoryAreaWRWord:    511,
	MemoryAreaHRWord:    511,
	MemoryAreaARWord:    959,
	MemoryAreaCIOWordFs: 6143,
	MemoryAreaWRWordFs:  511,
	MemoryAreaHRWordFs:  511,
	MemoryAreaTIMCF:     4095,
	MemoryAreaCNTCF:     4095,
	MemoryAreaTIMCFFs:   4095,
	MemoryAreaCNTCFFs:   4095,
	MemoryAreaTIMPV:     4095,
	MemoryAreaCNTPV:     4095,
	MemoryAreaDMBit:     32767,
	MemoryAreaDMWord:    32767,
	MemoryAreaIRPV:      15,
	MemoryAreaDRPV:      15,
}

// Max is the attribute of MemoryArea.
func (x MemoryArea) Max() uint16 {
	if v, ok := _MemoryAreaMapMax[x]; ok {
		return v
	}
	return 0
}

var _MemoryAreaMapOffset = map[MemoryArea]uint16{
	MemoryAreaCIOBit:    0,
	MemoryAreaWRBit:     0,
	MemoryAreaHRBit:     0,
	MemoryAreaARBit:     0,
	MemoryAreaCIOBitFs:  0,
	MemoryAreaWRBitFs:   0,
	MemoryAreaHRBitFs:   0,
	MemoryAreaCIOWord:   0,
	MemoryAreaWRWord:    0,
	MemoryAreaHRWord:    0,
	MemoryAreaARWord:    0,
	MemoryAreaCIOWordFs: 0,
	MemoryAreaWRWordFs:  0,
	MemoryAreaHRWordFs:  0,
	MemoryAreaTIMCF:     0,
	MemoryAreaCNTCF:     32768,
	MemoryAreaTIMCFFs:   0,
	MemoryAreaCNTCFFs:   32768,
	MemoryAreaTIMPV:     0,
	MemoryAreaCNTPV:     32768,
	MemoryAreaDMBit:     0,
	MemoryAreaDMWord:    0,
	MemoryAreaIRPV:      256,
	MemoryAreaDRPV:      512,
}

// Offset is the attribute of MemoryArea.
func (x MemoryArea) Offset() uint16 {
	if v, ok := _MemoryAreaMapOffset[x]; ok {
		return v
	}
	return 0
}

var _MemoryAreaMapOldCode = map[MemoryArea]uint8{
	MemoryAreaCIOBit:    0,
	MemoryAreaWRBit:     0,
	MemoryAreaHRBit:     0,
	MemoryAreaARBit:     0,
	MemoryAreaCIOBitFs:  64,
	MemoryAreaWRBitFs:   0,
	MemoryAreaHRBitFs:   0,
	MemoryAreaCIOWord:   128,
	MemoryAreaWRWord:    0,
	MemoryAreaHRWord:    0,
	MemoryAreaARWord:    128,
	MemoryAreaCIOWordFs: 192,
	MemoryAreaWRWordFs:  0,
	MemoryAreaHRWordFs:  0,
	MemoryAreaTIMCF:     1,
	MemoryAreaCNTCF:     1,
	MemoryAreaTIMCFFs:   65,
	MemoryAreaCNTCFFs:   65,
	MemoryAreaTIMPV:     129,
	MemoryAreaCNTPV:     129,
	MemoryAreaDMBit:     0,
	MemoryAreaDMWord:    130,
	MemoryAreaIRPV:      0,
	MemoryAreaDRPV:      156,
}

// OldCode is the attribute of MemoryArea.
func (x MemoryArea) OldCode() uint8 {
	if v, ok := _MemoryAreaMapOldCode[x]; ok {
		return v
	}
	return 0
}

var _MemoryAreaMapOldMax = map[MemoryArea]uint16{
	MemoryAreaCIOBit:    2555,
	MemoryAreaWRBit:     65535,
	MemoryAreaHRBit:     65535,
	MemoryAreaARBit:     959,
	MemoryAreaCIOBitFs:  2555,
	MemoryAreaWRBitFs:   65535,
	MemoryAreaHRBitFs:   65535,
	MemoryAreaCIOWord:   2555,
	MemoryAreaWRWord:    65535,
	MemoryAreaHRWord:    65535,
	MemoryAreaARWord:    959,
	MemoryAreaCIOWordFs: 2555,
	MemoryAreaWRWordFs:  65535,
	MemoryAreaHRWordFs:  65535,
	MemoryAreaTIMCF:     2047,
	MemoryAreaCNTCF:     2047,
	MemoryAreaTIMCFFs:   2047,
	MemoryAreaCNTCFFs:   2047,
	MemoryAreaTIMPV:     2047,
	MemoryAreaCNTPV:     2047,
	MemoryAreaDMBit:     65535,
	MemoryAreaDMWord:    32767,
	MemoryAreaIRPV:      65535,
	MemoryAreaDRPV:      2,
}

// OldMax is the attribute of MemoryArea.
func (x MemoryArea) OldMax() uint16 {
	if v, ok := _MemoryAreaMapOldMax[x]; ok {
		return v
	}
	return 0
}

var _MemoryAreaMapOldOffset = map[MemoryArea]uint16{
	MemoryAreaCIOBit:    0,
	MemoryAreaWRBit:     65535,
	MemoryAreaHRBit:     65535,
	MemoryAreaARBit:     2816,
	MemoryAreaCIOBitFs:  0,
	MemoryAreaWRBitFs:   65535,
	MemoryAreaHRBitFs:   65535,
	MemoryAreaCIOWord:   0,
	MemoryAreaWRWord:    65535,
	MemoryAreaHRWord:    65535,
	MemoryAreaARWord:    2816,
	MemoryAreaCIOWordFs: 0,
	MemoryAreaWRWordFs:  65535,
	MemoryAreaHRWordFs:  65535,
	MemoryAreaTIMCF:     0,
	MemoryAreaCNTCF:     2048,
	MemoryAreaTIMCFFs:   0,
	MemoryAreaCNTCFFs:   2048,
	MemoryAreaTIMPV:     0,
	MemoryAreaCNTPV:     2048,
	MemoryAreaDMBit:     65535,
	MemoryAreaDMWord:    0,
	MemoryAreaIRPV:      65535,
	MemoryAreaDRPV:      3,
}

// OldOffset is the attribute of MemoryArea.
func (x MemoryArea) OldOffset() uint16 {
	if v, ok := _MemoryAreaMapOldOffset[x]; ok {
		return v
	}
	return 0
}

var _MemoryAreaMapSize = map[MemoryArea]int{
	MemoryAreaCIOBit:    1,
	MemoryAreaWRBit:     1,
	MemoryAreaHRBit:     1,
	MemoryAreaARBit:     1,
	MemoryAreaCIOBitFs:  1,
	MemoryAreaWRBitFs:   1,
	MemoryAreaHRBitFs:   1,
	MemoryAreaCIOWord:   2,
	MemoryAreaWRWord:    2,
	MemoryAreaHRWord:    2,
	MemoryAreaARWord:    2,
	MemoryAreaCIOWordFs: 4,
	MemoryAreaWRWordFs:  4,
	MemoryAreaHRWordFs:  4,
	MemoryAreaTIMCF:     1,
	MemoryAreaCNTCF:     1,
	MemoryAreaTIMCFFs:   1,
	MemoryAreaCNTCFFs:   1,
	MemoryAreaTIMPV:     2,
	MemoryAreaCNTPV:     2,
	MemoryAreaDMBit:     1,
	MemoryAreaDMWord:    2,
	MemoryAreaIRPV:      4,
	MemoryAreaDRPV:      2,
}

// Size is the attribute of MemoryArea.
func (x MemoryArea) Size() int {
	if v, ok := _MemoryAreaMapSize[x]; ok {
		return v
	}
	return 0
}

// Val is the attribute of MemoryArea.
func (x MemoryArea) Val() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x MemoryArea) IsValid() bool {
	_, ok := _MemoryAreaNameMap[string(x)]
	return ok
}

// String implements the Stringer interface.
func (x MemoryArea) String() string {
	return x.Name()
}

// ParseMemoryArea converts a string to a MemoryArea.
func ParseMemoryArea(value string) (MemoryArea, error) {
	if x, ok := _MemoryAreaNameMap[value]; ok {
		return x, nil
	}
	if x, ok := _MemoryAreaNameMap[strings.ToLower(value)]; ok {
		return x, nil
	}
	return "", fmt.Errorf("%s is %w", value, ErrInvalidMemoryArea)
}

// MustParseMemoryArea converts a string to a MemoryArea, and panics if is not valid.
func MustParseMemoryArea(value string) MemoryArea {
	val, err := ParseMemoryArea(value)
	if err != nil {
		panic(err)
	}
	return val
}

var ErrInvalidPlcType = errors.New("not a valid PlcType")

var _PlcTypeName = "NewOld"

var _PlcTypeMapName = map[PlcType]string{
	PlcTypeNew: _PlcTypeName[0:3],
	PlcTypeOld: _PlcTypeName[3:6],
}

// Name is the attribute of PlcType.
func (x PlcType) Name() string {
	if v, ok := _PlcTypeMapName[x]; ok {
		return v
	}
	return fmt.Sprintf("PlcType(%d).Name", x)
}

var _PlcTypeMapDescription = map[PlcType]string{
	PlcTypeNew: "CS/CJ/CP/NSJ-series",
	PlcTypeOld: "CVM1/CV-series",
}

// Description is the attribute of PlcType.
func (x PlcType) Description() string {
	if v, ok := _PlcTypeMapDescription[x]; ok {
		return v
	}
	return fmt.Sprintf("PlcType(%d).Description", x)
}

// Val is the attribute of PlcType.
func (x PlcType) Val() int {
	return int(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x PlcType) IsValid() bool {
	_, ok := _PlcTypeMapName[x]
	return ok
}

// String implements the Stringer interface.
func (x PlcType) String() string {
	return x.Name()
}

var _PlcTypeNameMap = map[string]PlcType{
	_PlcTypeName[0:3]: PlcTypeNew,
	_PlcTypeName[3:6]: PlcTypeOld,
}

// ParsePlcType converts a string to a PlcType.
func ParsePlcType(value string) (PlcType, error) {
	if x, ok := _PlcTypeNameMap[value]; ok {
		return x, nil
	}
	return PlcType(0), fmt.Errorf("%s is %w", value, ErrInvalidPlcType)
}

var ErrInvalidState = errors.New("not a valid State")

var _StateName = "UnknownConnectingConnectedDisconnectedConnectClosed"

var _StateMapName = map[State]string{
	StateUnknown:       _StateName[0:7],
	StateConnecting:    _StateName[7:17],
	StateConnected:     _StateName[17:26],
	StateDisconnected:  _StateName[26:38],
	StateConnectClosed: _StateName[38:51],
}

// Name is the attribute of State.
func (x State) Name() string {
	if v, ok := _StateMapName[x]; ok {
		return v
	}
	return fmt.Sprintf("State(%d).Name", x)
}

// Val is the attribute of State.
func (x State) Val() int {
	return int(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x State) IsValid() bool {
	_, ok := _StateMapName[x]
	return ok
}

// String implements the Stringer interface.
func (x State) String() string {
	return x.Name()
}

var _StateNameMap = map[string]State{
	_StateName[0:7]:                    StateUnknown,
	strings.ToLower(_StateName[0:7]):   StateUnknown,
	_StateName[7:17]:                   StateConnecting,
	strings.ToLower(_StateName[7:17]):  StateConnecting,
	_StateName[17:26]:                  StateConnected,
	strings.ToLower(_StateName[17:26]): StateConnected,
	_StateName[26:38]:                  StateDisconnected,
	strings.ToLower(_StateName[26:38]): StateDisconnected,
	_StateName[38:51]:                  StateConnectClosed,
	strings.ToLower(_StateName[38:51]): StateConnectClosed,
}

// ParseState converts a string to a State.
func ParseState(value string) (State, error) {
	if x, ok := _StateNameMap[value]; ok {
		return x, nil
	}
	if x, ok := _StateNameMap[strings.ToLower(value)]; ok {
		return x, nil
	}
	return State(0), fmt.Errorf("%s is %w", value, ErrInvalidState)
}

// MarshalText implements the text marshaller method.
func (x State) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *State) UnmarshalText(text []byte) error {
	val, err := ParseState(string(text))
	if err != nil {
		return err
	}
	*x = val
	return nil
}

var ErrInvalidTcpCommand = errors.New("not a valid TcpCommand")

var _TcpCommandName = "FrameSend"

var _TcpCommandMapName = map[TcpCommand]string{
	TcpCommandFrameSend: _TcpCommandName[0:9],
}

// Name is the attribute of TcpCommand.
func (x TcpCommand) Name() string {
	if v, ok := _TcpCommandMapName[x]; ok {
		return v
	}
	return fmt.Sprintf("TcpCommand(%d).Name", x)
}

// Val is the attribute of TcpCommand.
func (x TcpCommand) Val() int {
	return int(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x TcpCommand) IsValid() bool {
	_, ok := _TcpCommandMapName[x]
	return ok
}

// String implements the Stringer interface.
func (x TcpCommand) String() string {
	return x.Name()
}

var _TcpCommandNameMap = map[string]TcpCommand{
	_TcpCommandName[0:9]: TcpCommandFrameSend,
}

// ParseTcpCommand converts a string to a TcpCommand.
func ParseTcpCommand(value string) (TcpCommand, error) {
	if x, ok := _TcpCommandNameMap[value]; ok {
		return x, nil
	}
	return TcpCommand(0), fmt.Errorf("%s is %w", value, ErrInvalidTcpCommand)
}

var ErrInvalidTransType = errors.New("not a valid TransType")

var _TransTypeName = "TcpUdp"

var _TransTypeMapName = map[TransType]string{
	TransTypeTcp: _TransTypeName[0:3],
	TransTypeUdp: _TransTypeName[3:6],
}

// Name is the attribute of TransType.
func (x TransType) Name() string {
	if v, ok := _TransTypeMapName[x]; ok {
		return v
	}
	return fmt.Sprintf("TransType(%d).Name", x)
}

// Val is the attribute of TransType.
func (x TransType) Val() int {
	return int(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x TransType) IsValid() bool {
	_, ok := _TransTypeMapName[x]
	return ok
}

// String implements the Stringer interface.
func (x TransType) String() string {
	return x.Name()
}

var _TransTypeNameMap = map[string]TransType{
	_TransTypeName[0:3]: TransTypeTcp,
	_TransTypeName[3:6]: TransTypeUdp,
}

// ParseTransType converts a string to a TransType.
func ParseTransType(value string) (TransType, error) {
	if x, ok := _TransTypeNameMap[value]; ok {
		return x, nil
	}
	return TransType(0), fmt.Errorf("%s is %w", value, ErrInvalidTransType)
}
